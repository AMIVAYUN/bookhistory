# Chapter2 JVM 이야기

## 인터프리팅과 클래스 로딩

JVM은 스택 기반의 해석 머신이다. CPU처럼 레지스터는 없지만 일부 결과를 실행 스택에 보관하며 이 스택위에 쌓인 값을 가져와서 계산한다.

**JVM의 인터프리터의 기본 로직은 평가 스택을 이용해서 가장 마지막에 실행된 명령어와 독립적으로 프로그램을 구성하는 옵코드를 하나씩 순서대로 처리하는 while 루프 안의 switch문이라고 이해하면 된다.**

실행 순서

1. helloworld.java를 실행
2. OS가 자바 바이너리를 구동
3. 자바 가상환경 구성 및 스택 머신 초기화
4. 실제 유저의 [helloworld.java](http://helloworld.java) 클래스 파일 참조
5. main() 메서드를 통해 진입

<aside>
💡

이 과정에서 클래스로딩 메커니즘이 작용하는데 자바 프로세스가 초기화되면 사슬처럼 줄 지어서 연결된 클래스로더가 차례 차례 작동하게 된다.

</aside>

---

## 클래스로더

> [https://velog.io/@jifrozen/JVM-구성요소-1-클래스-로더](https://velog.io/@jifrozen/JVM-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C-1-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%8D%94)
> 
1. 부트스트랩 클래스가 런타임 코어 클래스를 로드
    1. 부트스트랩 클래스 로더란?
    
    <aside>
    💡
    
    ## 부트스트랩 클래스 로더( Bootstrap Class Loader )
    
    Bootstrap ClassLoader 는 다른 모든 ClassLoader 의 부모가 되는 ClassLoader 이다. JVM 시작 시 가장 최초로 실행되는 클래스 로더이다. 부트스트랩 클래스 로더는 자바 클래스를 로드하는 것이 아닌, 자바 클래스를 로드할 수 있는 자바 자체의 클래스 로더와 최소한의 자바 클래스(java.lang.Object, Class, ClassLoader)만을 로드한다.
    
    가장 상위의 ClassLoader 이므로 다른 ClassLoader 와는 다르게 탑재되는 운영체제에 맞게 네이티브 코드로 쓰여있다.
    
    Java 8
    
    jre/lib/rt.jar 및 기타 핵심 라이브러리와 같은 JDK의 내부 클래스를 로드한다.
    
    Java 9 이후
    
    더 이상 /re.jar이 존재하지 않으며, /lib 내에 모듈화되어 포함됐다. 이제는 정확하게 ClassLoader 내 최상위 클래스들만 로드한다.
    
    </aside>
    
2. 확장 클래스로더 생성 
    1. 확장 클래스 로더란?
    
    <aside>
    💡
    
    ## 확장 클래스 로더 (Extension Class Loader)
    
    BootStrap ClassLoader 다음으로 우선순위를 가지는 ClassLoader 이다.
    
    확장 자바 클래스들을 로드한다. java.ext.dirs 환경 변수에 설정된 디렉토리의 클래스 파일을 로드하고, 이 값이 설정되어 있지 않은 경우 ${JAVA_HOME}/jre/lib/ext 에 있는 클래스 파일을 로드한다.
    
    </aside>
    
3. 애플리케이션 클래스 로더가 생성
    1. 애플리케이션 클래스 로더란?
    
    <aside>
    💡
    
    ## 애플리케이션 클래스 로더 (Application Class Loader)
    
    자바 프로그램 실행 시 지정한 Classpath에 있는 클래스 파일 혹은 jar에 속한 클래스들을 로드한다. 쉽게 말하자면, 우리가 만든 .class 확장자 파일을 로드한다.
    
    시스템 클래스로더라고도 불리지만 부트스트랩 클래스로더가 불러오는 시스템 클래스는 로드하지 않기 때문에 애플리케이션 클래스로더라 부르는 것이 바람직하다.
    
    </aside>
    

자바는 프로그램 실행 중 처음 보는 새 클래스를 디펜던시에 로드한다. 

→ 클래스를 찾지 못하면 부모 클래스로더에게 룩업( 찾기 )를 위임한다. 

→ 결국 못찾으면 ClassNotFoundException이 발생한다.

---

## 바이트코드 실행

자바 소스 코드는 실행되기까지 많은 변환과정을 거친다.

1. 자바 컴파일러( javac )를 이용해서 컴파일 한다.
    1. 이를 통해 모든 소스 코드를 바이트코드가 가득찬 .class 파일로 바꾸게 된다.
        
        ![IMG_4346.jpg](img%2FIMG_4346.jpg)
        
        <aside>
        💡
        
        이러한 바이트코드는 이른바 **IR( 중간 표현형 )**이라고 불리는데, 컴퓨터 아키텍쳐의 영향을 받지 않고 이식성이 좋아 JVM만 있다면 어디서든 실행할 수 있고 자바 언어에 대해서도 추상화 되어있다.
        
        </aside>
        
        <aside>
        💡
        
        JVM은 자바 언어에 대해 어느정도 독립적이어서 스칼라 컴파일러( scalac )로 컴파일한 바이트코드도 실행 가능하다.
        
        </aside>
        
        이렇게 컴파일러가 생성한 클래스 파일은 VM 명세서에 정의된 구조에 따라 정보를 가지고 있게된다.
        
        | 매직 넘버 | 0XCA.. |
        | --- | --- |
        | 포맷 버전 | 메이저/마이너 버전 |
        | 상수 풀 | 클래스 상수들이 모여있음 |
        | 액세스 플래그 | 추상, 정적 클래스등 클래스의 종류를 나타냄 |
        | this 클래스 | 현재 클래스의 이름 |
        | 슈퍼클래스 | 부모클래스 명 |
        | 인터페이스 | 클래스가 구현한 모든 인터페이스 |
        | 필드 | 클래스에 들어있는 모든 필드 |
        | 메서드 | 클래스에 들어있는 모든 메서드 |
        | 속성 | 클래스가 지닌 모든 속성 |
        
        ### 매직 넘버
        
        <aside>
        💡
        
        4바이트 16진수로 클래스 파일임을 나타내는 번호
        
        </aside>
        
        ### 포맷 버전
        
        <aside>
        💡
        
        클래스를 실행하는 대상 JVM이 컴파일 JVM보다 낮으면 안되기에 클래스로더의 호환성 보장을 위해 사용
        
        </aside>
        
        ### 상수 풀
        
        <aside>
        💡
        
        코드에 등장하는 상숫값 ( 클래스명, 인터페이스명, 필드명 ) 이 담기며 JVM은 코드 실행시 런타임에 배치된 메모리 대신, 상수 풀에서 필요한 값을 찾아보고 참조한다.
        
        </aside>
        
        ### 액세스 플래그
        
        <aside>
        💡
        
        클래스에 적용한 수정자를 결정한다. 
        
        1. 첫 부분은 일반 프로퍼티 → public, final, interface, abstract인지 나타냄
        2. 끝 부분에 합성 클래스인지, annotation인지 enum인지등을 나타낸다.
        </aside>
        
        ### this, super, interface
        
        <aside>
        💡
        
        클래스에 포함된 타입 계층을 나타내는데 각각 상수 풀을 가리키는 인덱스로 표시된다.
        
        </aside>
        
        ### 필드, 메서드
        
        <aside>
        💡
        
        필드와 메서드는 시그니처 비슷한 구조를 정의하고 여기에 수정자도 포함되어 있다.
        
        </aside>
        
        ### 속성
        
        <aside>
        💡
        
        복잡하고 크기가 고정되지 않은 구조를 나타낼 때 쓰임
        
        ex ) 메서드는 Code 속성으로 특정 메서드와 연관된 바이트코드를 나타낸다.
        
        </aside>
        
    
    ### 예시
    
    ```java
    public class HelloWorld{
    	public static void main( String[] args ){
    		for( int i = 0; i < 10; i++ ){
    			System.out.println( "Hello world" );
    		}
    	}
    }
    ```
    
    ```java
    public class HelloWorld{
    	public HelloWorld();
    	Code:
    		0: aload_0 // this 레퍼런스를 스택 상단에 올려놓는 aload_0 명렁이 실행된다.
    		1: invokespecial #1 // 슈퍼생성자들을 호출하고 객체를 생성하는 등 특정 작업을 담당하는 인스턴스 메서드 실행
    				// HelloWorld는 디폴트 생성자를 오버라이드한 코드가 없기에 Object 디폴트 생성자가 매칭됨.
    		4: return
    	
    	public static void main( java.lang.String[] );
    	Code:
    		0: iconst_0 // 정수형 상수 0 스택에 푸시
    		1: istore_1 // 이 상숫값을 오프셋 1에 위치한 지역변수(루프의i)에 저장한다.
    		2: iload_1 // 오프셋의 변수(i)를 스택으로 로드한 뒤
    		3: bipush // 상수 10을 푸쉬하고
    		5: if_icmpge // 둘을 비교
    		8: getstatic // 실패시 여기로
    		11: ldc // Hello world 문자열을 로드하고
    		13: invokevirtual // 이 클래스에 속한 인스턴스 메서드를 실행한다.
    		16: iinc // 정수 값이 하나 증가한다.
    		19: goto
    		22: return
    }
    ```
    

---

## 핫스팟 입문

자바의 가장 큰 변화를 가져온 가상 머신으로 요체인 핫스팟 가상머신이라 불린다.

![IMG_4347.jpg](img%2FIMG_4347.jpg)

### JIT 컴파일이란?

<aside>
💡

자바 프로그램은 바이트코드 인터프리터가 가상화한 스택 머신에서 명령어를 실행하며 시작된다.

CPU를 추상화한 구조라서 다른 플랫폼에서도 클래스 파일을 문제없이 실행할 수 있지만, 프로그램이 성능을 최대로 내려면 네이티브 기능을 활용해 CPU에서 직접 프로그램을 실행시켜야 한다.

이를 위해, 핫스팟은 프로그램 단위( 메서드, 루프 )를 **인터프리티드 바이트코드에서 네이티브 코드로 컴파일한다. 이 역할을 JIT 컴파일러가 하는 것이다.**

</aside>

<aside>
💡

JVM은 `javac`가 생성한 바이트코드를 실행하는데, 여기서 **JIT 컴파일러**가 중요한 역할을 한다.

JIT 컴파일러는 바이트코드를 실행하는 동안 **실행 속도를 최적화하기 위해** 일부 코드 또는 반복적으로 실행되는 부분을 네이티브 코드로 변환한다

이 변환은 "한 줄씩 인터프리트" 하는 방식보다는, **필요한 부분이나 자주 실행되는 코드 블록**을 네이티브 코드로 컴파일하여 실행 속도를 높이는 방식으로 이루어집니다.

즉, JIT 컴파일러가 컴파일한 코드는 우리가 짠 코드와는 많이 다르다.

</aside>

자바는 프로필 기반 최적화( profile-guided optimization )를 응용하는 환경으로 동적 인라이닝, 가상호출 등으로 성능 개선이 가능하다.

<aside>
💡

동적 인라이닝이란?

동적 인라이닝(Dynamic Inlining)은 프로그램 실행 중에 **JIT(Just-In-Time) 컴파일러**가 최적화를 위해 메서드 호출을 **인라인** 방식으로 변환하는 기술이다. 이 과정에서 메서드 호출을 실제로 호출하지 않고, 메서드의 코드를 호출 위치에 **직접 삽입**하여 성능을 최적화하는 방법이다.

### 동적 인라이닝의 개념

- 자바 같은 언어에서는 메서드 호출이 많아지면 호출 스택을 관리하는 데 시간이 걸리거나 성능 저하가 발생할 수 있다.
- **JIT 컴파일러**는 프로그램이 실행되는 동안, 성능이 중요한 메서드(특히 자주 호출되는 메서드나 작은 메서드)를 감지하고, 해당 메서드를 호출하는 대신, 메서드의 코드를 호출 위치에 **직접 삽입**하는 최적화를 수행한다.
- 이렇게 하면 메서드 호출에 필요한 오버헤드가 사라지고, 코드를 실행하는 속도가 빨라지게 된다.

### 동적 인라이닝의 특징

1. **동적(Dynamic)**:
    - 실행 중에 런타임 정보를 바탕으로 이루어진다. JIT 컴파일러는 프로그램 실행 중 메서드 호출의 빈도와 패턴을 분석하여 인라이닝 여부를 결정한다.
    - 만약 특정 메서드가 매우 자주 호출되는 것으로 확인되면, JIT 컴파일러는 해당 메서드를 인라인으로 변환한다.
2. **성능 최적화**:
    - 메서드 호출을 줄여 메서드 호출에 필요한 시간과 메모리 오버헤드를 줄인다.
    - 인라이닝된 코드가 최적화되기 쉽기 때문에, 추가적인 최적화(예: 상수 전파, 루프 최적화 등)도 가능해진다.
3. **가상 메서드와 동적 인라이닝**:
    - 다형성을 가진 메서드(예: 오버라이드된 메서드)는 호출 시점에 어느 메서드가 호출될지 결정된다.
    - JIT 컴파일러는 실행 중에 가상 메서드의 실제 타입을 확인하고, 가장 자주 호출되는 경우(핫스팟)를 인라인 처리한다.

### 예시

```java
java
코드 복사
class Example {
    int add(int a, int b) {
        return a + b;
    }

    void calculate() {
        int result = add(2, 3);
        System.out.println("Result: " + result);
    }
}

```

위 코드에서 `calculate()` 메서드가 실행될 때 `add()` 메서드가 자주 호출된다면, JIT 컴파일러는 `add(2, 3)` 호출을 제거하고, 그 위치에 `a + b`를 직접 삽입하여 실행 속도를 높일 수 있다.

동적 인라이닝 덕분에 자바 프로그램의 실행 속도가 더욱 빨라지고, 메서드 호출의 오버헤드가 줄어드는 이점이 있다.

</aside>

### 가비지 컬렉션이란?

<aside>
💡

자바는 프로세스를 이용해 힙 메모리를 자동적으로 관리하는 방식인데 즉 애플리케이션에서 사용하지 않는 메모리를 자동으로 수거하는 기능을 말한다.

</aside>

자세한 내용은 6,7,8장에서 다룬다.

### JVM 구현체 종류

- Open JDK
    - 자바 기준 구현체를 제공하는 특별한 오픈 소스 프로젝트, 오라클이 주관하며 자바 릴리즈 기준을 발표한다.
- 줄루
    - 아줄 시스템이 개발한 자바 풀 인증을 받은 무료 OpenJDK 구현체로 상용 라이센스라 자유롭게 사용 가능하다.
- 안드로이드
    - 안드로이드는 과거 non-JVM 가상 머신 용도의 .dex 포맷으로 변환하기 위해 여러 라이브러리와 교차 컴파일러를 사용했다. 현재는 Openjdk 8 클래스 라이브러리를 사용하는 방향으로 가는 추세이다.